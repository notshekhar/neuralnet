!function(t){var s={};function e(o){if(s[o])return s[o].exports;var i=s[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,e),i.l=!0,i.exports}e.m=t,e.c=s,e.d=function(t,s,o){e.o(t,s)||Object.defineProperty(t,s,{enumerable:!0,get:o})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,s){if(1&s&&(t=e(t)),8&s)return t;if(4&s&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(e.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&s&&"string"!=typeof t)for(var i in t)e.d(o,i,function(s){return t[s]}.bind(null,i));return o},e.n=function(t){var s=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(s,"a",s),s},e.o=function(t,s){return Object.prototype.hasOwnProperty.call(t,s)},e.p="",e(e.s=0)}([function(t,s,e){let o=e(1);window.NeuralNetwork=(t,s)=>new o(t,s)},function(t,s,e){let o=e(2);class i{constructor(t,s){this.nodes=t,this.lr=s||.01,this.activation=i.sigmoid,this.dactivation=i.dsigmoid,this.weights=[],this.biases=[];for(let t=0;t<this.nodes.length-1;t++)this.weights.push(new o(this.nodes[t+1],this.nodes[t]).randomize());for(let t=1;t<this.nodes.length;t++)this.biases.push(new o(this.nodes[t],1).randomize())}static tanh(t){return Math.tanh(t)}static dtanh(t){return 1/pow(Math.cosh(t),2)}static sigmoid(t){return 1/(1+Math.exp(-t))}static dsigmoid(t){return t*(1-t)}query(t){let s=o.fromArray(t);for(let t=0;t<this.weights.length;t++)(s=o.multiply(this.weights[t],s)).add(this.biases[t]),s.map(this.activation);return s.toArray()}learn(t,s){let e=o.fromArray(s),i=o.fromArray(this.query(t)),r=[],a=o.fromArray(t);for(let t=0;t<this.weights.length;t++)r.push(a),(a=o.multiply(this.weights[t],a)).add(this.biases[t]),a.map(this.activation);let n=o.subtract(e,i),l=o.map(i,this.dactivation);l.multiply(n),l.multiply(this.lr);for(let t=r.length-1;t>=0;t--){let s=o.multiply(l,o.transpose(r[t]));this.weights[t].add(s),this.biases[t].add(l),n=o.multiply(o.transpose(this.weights[t]),n),(l=o.map(r[t],this.dactivation)).multiply(n),l.multiply(this.lr)}}getModel(){let t=this,s={nodes:t.nodes,lr:t.lr,activation:t.activation,dactivation:t.dactivation,weights:[],biases:[]};for(let e of t.weights){let t={rows:e.rows,cols:e.cols,data:[]};for(let s of e.data){let e=[];for(let t of s)e.push(t);t.data.push(e)}s.weights.push(t)}for(let e of t.biases){let t={rows:e.rows,cols:e.cols,data:e.data};s.biases.push(t)}return s}static formModel(t){let s=new i(t.nodes,t.lr);s.nodes=t.nodes,s.lr=t.lr,s.activation=t.activation,s.dactivation=t.dactivation;for(let e=0;e<s.weights.length;e++){s.weights[e].rows=t.weights[e].rows,s.weights[e].cols=t.weights[e].cols;for(let o=0;o<t.weights[e].rows;o++)for(let i=0;i<t.weights[e].cols;i++)s.weights[e].data[o][i]=t.weights[e].data[o][i];s.weights[e].rows=t.weights[e].rows}return s}copy(){let t=this.getModel();return i.formModel(t)}mutate(t){for(let s of this.weights)s.map(t);for(let s of this.biases)s.map(t)}merge(t,s=.5){let e=1-s,o=s;for(let s=0;s<this.nodes.length;s++)if(this.nodes[s]!=t.nodes[s])return void console.error("Neural Networks can not be merged");this.lr=this.lr*e+t.lr*o;for(let s=0;s<this.weights.length;s++)for(let i=0;i<this.weights[s].rows;i++)for(let r=0;r<this.weights[s].cols;r++)this.weights[s].data[i][r]=this.weights[s].data[i][r]*e+t.weights[s].data[i][r]*o;for(let s=0;s<this.biases.length;s++)for(let i=0;i<this.biases[s].rows;i++)for(let r=0;r<this.biases[s].cols;r++)this.biases[s].data[i][r]=this.biases[s].data[i][r]*e+t.biases[s].data[i][r]*o;return this}setActivation(t,s){this.activation=t,this.dactivation=s}setLearningRate(t){this.lr=t}}t.exports=i},function(t,s,e){class o{constructor(t,s){this.rows=t,this.cols=s,this.data=Array(this.rows).fill().map(()=>Array(this.cols).fill(0))}static fromArray(t){return new o(t.length,1).map((s,e)=>t[e])}static subtract(t,s){if(t.rows===s.rows&&t.cols===s.cols)return new o(t.rows,t.cols).map((e,o,i)=>t.data[o][i]-s.data[o][i]);console.log("Columns and Rows of A must match Columns and Rows of B.")}toArray(){let t=[];for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t.push(this.data[s][e]);return t}randomize(){return this.map(t=>2*Math.random()-1)}add(t){return t instanceof o?this.rows!==t.rows||this.cols!==t.cols?void console.log("Columns and Rows of A must match Columns and Rows of B."):this.map((s,e,o)=>s+t.data[e][o]):this.map(s=>s+t)}static transpose(t){return new o(t.cols,t.rows).map((s,e,o)=>t.data[o][e])}static multiply(t,s){if(t.cols===s.rows)return new o(t.rows,s.cols).map((e,o,i)=>{let r=0;for(let e=0;e<t.cols;e++)r+=t.data[o][e]*s.data[e][i];return r});console.log("Columns of A must match rows of B.")}multiply(t){return t instanceof o?this.rows!==t.rows||this.cols!==t.cols?void console.log("Columns and Rows of A must match Columns and Rows of B."):this.map((s,e,o)=>s*t.data[e][o]):this.map(s=>s*t)}map(t){for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++){let o=this.data[s][e];this.data[s][e]=t(o,s,e)}return this}copy(){let t=new o(this.rows,this.cols);for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++)t.data[s][e]=t.data[s][e];return t}static map(t,s){return new o(t.rows,t.cols).map((e,o,i)=>s(t.data[o][i],o,i))}print(){return console.table(this.data),this}serialize(){return JSON.stringify(this)}static deserialize(t){"string"==typeof t&&(t=JSON.parse(t));let s=new o(t.rows,t.cols);return s.data=t.data,s}}t.exports=o}]);